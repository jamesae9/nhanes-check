<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NHANES Manuscript Checker (Python)</title>
  
  <!-- Document processing libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.19/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  
  <!-- Pyodide - Python in the browser -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  
  <!-- Embedded CSS (no external file needed) -->
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 30px;
    }
    h2 {
      color: #3498db;
      margin-top: 30px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .upload-section {
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 5px;
      border: 1px solid #ddd;
      margin-bottom: 20px;
    }
    textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
    }
    .button-container {
      margin: 20px 0;
    }
    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    .results-section {
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      border: 1px solid #ddd;
      margin-top: 20px;
    }
    .check-item {
      margin-bottom: 15px;
      padding: 15px;
      border-radius: 4px;
    }
    .pass {
      background-color: #e7f7e7;
      border-left: 4px solid #28a745;
    }
    .fail {
      background-color: #ffeaea;
      border-left: 4px solid #dc3545;
    }
    .not-nhanes {
      background-color: #f8f9fa;
      border-left: 4px solid #6c757d;
    }
    .skipped {
      background-color: #f8f9fa;
      border-left: 4px solid #6c757d;
    }
    .hidden {
      display: none;
    }
    .file-upload {
      margin: 15px 0;
    }
    .summary {
      font-weight: bold;
      font-size: 18px;
      margin-bottom: 20px;
    }
    .pyodide-loading {
      text-align: center;
      padding: 20px;
      font-weight: bold;
      color: #3498db;
    }
    .loading-indicator {
      margin-top: 10px;
      font-style: italic;
      color: #666;
    }
    .footer {
      margin-top: 30px;
      text-align: center;
      font-size: 14px;
      color: #777;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>NHANES Manuscript Checker (Python)</h1>
    
    <!-- Pyodide loading indicator -->
    <div id="pyodideLoading" class="pyodide-loading">
      <div>Loading Python environment... Please wait.</div>
      <div class="loading-indicator">This may take a moment on first load.</div>
      <div id="loadingProgress">Initializing...</div>
    </div>
    
    <!-- Main app content (hidden until Python is ready) -->
    <div id="appContent" class="hidden">
      <div class="upload-section">
        <h2>Check Manuscript</h2>
        <p>Paste manuscript text or upload a file below:</p>
        
        <textarea id="manuscriptText" rows="10" placeholder="Paste manuscript text here..."></textarea>
        
        <div class="file-upload">
          <label for="manuscriptFile">Or upload a file:</label>
          <input type="file" id="manuscriptFile" accept=".txt,.docx,.pdf">
        </div>
        
        <div class="button-container">
          <button id="checkButton" disabled>Check Manuscript</button>
          <button id="clearButton">Clear</button>
        </div>
      </div>
      
      <div class="results-section hidden" id="results">
        <h2>Manuscript Check Results</h2>
        <div id="resultsContent"></div>
      </div>
    </div>
    
    <footer class="footer">
      <p>NHANES Manuscript Checker (Python/Pyodide Version)</p>
    </footer>
  </div>

  <!-- Embedded bridge.js -->
  <script>
    // File handling bridge between JavaScript and Python
    window.NHANESBridge = {
      async fetchTextFromFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error(`Error reading file: ${e.target.error}`));
          reader.readAsText(file);
        });
      },

      async fetchArrayBufferFromFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error(`Error reading file: ${e.target.error}`));
          reader.readAsArrayBuffer(file);
        });
      },

      showUILoading(message = "Processing...") {
        const textarea = document.getElementById('manuscriptText');
        const checkButton = document.getElementById('checkButton');
        const clearButton = document.getElementById('clearButton');
        const fileInput = document.getElementById('manuscriptFile');
        
        if (textarea) textarea.value = message;
        if (textarea) textarea.disabled = true;
        if (checkButton) checkButton.disabled = true;
        if (clearButton) clearButton.disabled = true;
        if (fileInput) fileInput.disabled = true;
      },

      hideUILoading(enableCheckButton = true) {
        const textarea = document.getElementById('manuscriptText');
        const checkButton = document.getElementById('checkButton');
        const clearButton = document.getElementById('clearButton');
        const fileInput = document.getElementById('manuscriptFile');
        
        if (textarea) textarea.disabled = false;
        if (checkButton) checkButton.disabled = !enableCheckButton;
        if (clearButton) clearButton.disabled = false;
        if (fileInput) fileInput.disabled = false;
      }
    };

    // Update loading message with status
    function updateLoadingStatus(message) {
      const progressElem = document.getElementById('loadingProgress');
      if (progressElem) {
        progressElem.textContent = message;
      }
    }
    
    window.updateLoadingStatus = updateLoadingStatus;
  </script>

  <!-- Embedded Pyodide Loader and Python Code -->
  <script>
    // Loads Pyodide and Python implementation
    async function main() {
      try {
        console.log("Loading Pyodide...");
        updateLoadingStatus("Loading Pyodide core...");
        const pyodide = await loadPyodide();
        window.pyodide = pyodide;
        
        console.log("Loading Python packages...");
        updateLoadingStatus("Loading Python packages...");
        await pyodide.loadPackagesFromImports('import re');
        
        console.log("Loading Python implementation...");
        updateLoadingStatus("Loading NHANES Checker implementation...");
        
        // The Python code as a string (all-in-one approach)
        const pythonCode = `
import re
import js
from pyodide.ffi import create_proxy
from js import document, console, mammoth, pdfjsLib, alert, window
from datetime import datetime

# --- NHANES Checker Functions ---

def check_for_nhanes(text):
    """Look for mentions of NHANES or National Health and Nutrition Examination Survey"""
    nhanes_regex = r'\\bNHANES\\b|\\bNational Health and Nutrition Examination Survey\\b'
    return bool(re.search(nhanes_regex, text, re.IGNORECASE))

def check_nhanes_citation(text):
    """Look for proper citation mentions"""
    citation_patterns = [
        r'Centers for Disease Control and Prevention \\(CDC\\)',
        r'National Center for Health Statistics \\(NCHS\\)',
        r'https?:\\/\\/www\\.cdc\\.gov\\/nchs\\/nhanes',
        r'NHANES protocol was approved by the NCHS Research Ethics Review Board',
        r'NHANES data are publicly available'
    ]
    
    found_patterns = []
    
    for pattern in citation_patterns:
        if re.search(pattern, text, re.IGNORECASE):
            found_patterns.append(pattern.replace('\\\\', ''))
    
    # Check for methods/methodology section
    has_methods_section = bool(re.search(r'\\b(?:methods?|methodology)\\b', text, re.IGNORECASE))
    
    if len(found_patterns) >= 2 and has_methods_section:
        return {
            'passed': True,
            'details': f'NHANES properly cited. Found {len(found_patterns)} citation elements and methods section.'
        }
    else:
        issues = []
        if len(found_patterns) < 2:
            issues.append(f'Missing proper NHANES citation elements (found only {len(found_patterns)}, need at least 2)')
        if not has_methods_section:
            issues.append("No apparent methods section found")
        
        return {
            'passed': False,
            'details': f'NHANES citation issues: {"; ".join(issues)}'
        }

def check_survey_design_acknowledgment(text):
    """Check for survey design acknowledgment (temporarily disabled)"""
    return {
        'passed': True,  # Keeps it from being treated as a critical failure for now
        'skipped': True,  # Add the skipped flag
        'details': "Check for Survey Design Acknowledgment is currently disabled."
    }

def check_weighting_methodology(text):
    """Check for weighting methodology (temporarily disabled)"""
    return {
        'passed': True,  # Keeps it from being treated as a critical failure for now
        'skipped': True,  # Add the skipped flag
        'details': "Check for Weighting Methodology is currently disabled."
    }

def check_nhanes_date_range(text):
    """
    Checks text for year ranges potentially related to NHANES or similar datasets.
    Validates ranges based on:
    1. Plausibility (within reasonable year boundaries: MIN_PLAUSIBLE_YEAR to currentYear).
    2. Start year is odd, end year is even.
    """
    # Configuration for plausibility
    MIN_PLAUSIBLE_YEAR = 1950
    current_year = datetime.now().year
    MAX_PLAUSIBLE_YEAR = current_year

    # Regex to find potential year ranges, possibly associated with NHANES
    cycle_regex = r'(?:NHANES|National Health and Nutrition Examination Survey)?\\s*(?:data)?\\s*(?:from)?\\s*(?:the)?\\s*(?:years?)?\\s*(?:(?:19|20)\\d{2})(?:\\s*[-–—]\\s*(?:(?:19|20)\\d{2}))?|(?:(?:19|20)\\d{2})(?:\\s*[-–—]\\s*(?:(?:19|20)\\d{2}))?\\s*(?:NHANES|National Health and Nutrition Examination Survey)'
    
    matches = re.findall(cycle_regex, text, re.IGNORECASE) or []
    found_valid_range = False
    found_invalid_range = False
    found_implausible_range = False
    valid_range_details = []
    invalid_range_details = []
    implausible_range_details = []
    
    if not matches:
        # Broader search for *any* YYYY-YYYY pattern if specific NHANES context is missed
        generic_range_regex = r'(?:19|20)\\d{2}\\s*[-–—]\\s*(?:19|20)\\d{2}'
        matches = re.findall(generic_range_regex, text) or []
    
    # If still no matches, we can't perform the check effectively
    if not matches:
        return {
            'passed': True,  # Pass leniently if no range is mentioned
            'details': "No potential year ranges found to validate."
        }
    
    year_regex = r'(?:19|20)\\d{2}'
    
    for match_text in matches:
        years = [int(year) for year in re.findall(year_regex, match_text)]
        
        # We are only interested in pairs of years (start-end)
        if len(years) == 2:
            start_year, end_year = years
            
            # Plausibility Checks
            is_plausible = (
                start_year >= MIN_PLAUSIBLE_YEAR and
                end_year <= MAX_PLAUSIBLE_YEAR and
                end_year >= start_year
            )
            
            if not is_plausible:
                found_implausible_range = True
                implausible_range_details.append(f"{start_year}-{end_year} (in \\"{match_text}\\")")
                continue  # Skip validation for this implausible range
            
            # Validation Check (Odd Start, Even End)
            if start_year % 2 == 1 and end_year % 2 == 0:
                # Meets the odd-start, even-end criteria
                found_valid_range = True
                valid_range_details.append(f"{start_year}-{end_year}")
            else:
                # Is a plausible date range but fails the odd/even rule
                found_invalid_range = True
                invalid_range_details.append(f"{start_year}-{end_year} (in \\"{match_text}\\")")
    
    # Determine final result based on findings
    details = ""
    passed = True  # Default to passing unless an explicit invalid range is found
    
    if found_valid_range:
        passed = True  # At least one valid range found
        details = f"Valid OddStart-EvenEnd date range(s) found: {', '.join(list(set(valid_range_details)))}."
        if found_invalid_range:
            details += f" (Also found plausible ranges failing the OddStart-EvenEnd rule: {', '.join(list(set(invalid_range_details)))})"
    elif found_invalid_range:
        passed = False  # Explicitly invalid ranges found, and no valid ones
        details = f"No valid OddStart-EvenEnd ranges confirmed. Found plausible ranges with issues: {', '.join(list(set(invalid_range_details)))}."
    elif found_implausible_range:
        # Only found ranges that were filtered out as implausible (e.g., page numbers, future dates)
        passed = True  # Lenient pass - no *date* ranges were found to violate the rule
        details = "Found number ranges, but they were filtered out as unlikely calendar year ranges (e.g., potentially page numbers or out of date bounds)."
    else:
        # Matches were found by regex, but didn't yield 2 years, or something unexpected occurred.
        passed = True  # Pass leniently
        details = "Could not definitively identify plausible year ranges for validation from the text patterns found."
    
    return {'passed': passed, 'details': details}

def extract_manuscript_topics(text):
    """Extract the main health topics from the manuscript based on keyword frequency"""
    # Extract title and abstract
    title_match = re.search(r'^(?:Title\\s*[:\\s]*)?([^\\n]+)', text, re.IGNORECASE)
    abstract_regex = r'\\bAbstract\\b([\\s\\S]*?)(?=\\n\\s*\\b(Keywords|Introduction|Background|Methods)\\b|\\n{2,})'
    abstract_match = re.search(abstract_regex, text, re.IGNORECASE)
    
    title = title_match.group(1).strip() if title_match else ""
    abstract = abstract_match.group(1).strip() if abstract_match else ""
    
    # Focus analysis on title and abstract; fallback to first ~500 words
    analysis_text = (title + " " + abstract).strip() or text[:3000]
    
    if not analysis_text:
        return ["General Health/Unknown"]  # Default if no text
    
    # Domain keywords
    health_domains = {
        "Cardiovascular": ["heart", "cardiac", "cardiovascular", "blood pressure", "hypertension", "cholesterol", "stroke", "atherosclerosis", "vascular", "lipids", "arrhythmia"],
        "Nutrition/Diet": ["diet", "dietary", "food", "nutrition", "nutrient", "intake", "consumption", "supplement", "eating pattern", "malnutrition", "vitamin", "mineral", "fiber", "calories"],
        "Metabolic/Endocrine": ["diabetes", "insulin", "glucose", "metabolic syndrome", "obesity", "BMI", "body mass index", "thyroid", "endocrine", "adiposity", "waist circumference", "hormone"],
        "Epidemiology/Public Health": ["prevalence", "incidence", "risk factor", "population", "demographic", "public health", "mortality", "morbidity", "surveillance", "trends", "disparities", "socioeconomic"],
        "Mental Health/Neurology": ["depression", "anxiety", "psychiatric", "mental", "psychological", "cognitive", "cognition", "neurologic", "stress", "mood", "suicide"],
        "Respiratory": ["lung", "pulmonary", "respiratory", "asthma", "COPD", "breathing", "sleep apnea", "spirometry"],
        "Oncology": ["cancer", "tumor", "oncology", "malignancy", "carcinoma", "neoplasm"],
        "Pediatrics": ["child", "children", "adolescent", "pediatric", "youth", "infant", "growth", "development"],
        "Geriatrics": ["elderly", "older adults", "aging", "geriatric", "seniors", "frailty"],
        "Renal/Urology": ["kidney", "renal", "nephrology", "chronic kidney disease", "CKD", "urinary", "urology"],
        "Musculoskeletal/Physical Activity": ["bone", "muscle", "physical activity", "exercise", "sedentary", "osteoporosis", "arthritis", "sarcopenia", "fitness"],
        "Environmental Health": ["exposure", "pollutant", "environment", "toxin", "heavy metal", "pesticide", "air quality", "lead", "mercury", "cadmium"],
        "Infectious Disease": ["infection", "virus", "bacteria", "antibody", "vaccine", "hepatitis", "HIV"],
        "Gastroenterology": ["gut", "gastrointestinal", "liver", "hepatic", "digestive"],
        "Allergy/Immunology": ["allergy", "asthma", "immune", "inflammation", "antibody"]
    }
    
    domain_scores = {}
    
    for domain, keywords in health_domains.items():
        domain_scores[domain] = 0
        for keyword in keywords:
            # Case-insensitive, whole word match
            regex = r'\\b' + re.escape(keyword) + r'\\b'
            matches = len(re.findall(regex, analysis_text, re.IGNORECASE) or [])
            if matches > 0:
                domain_scores[domain] += matches
    
    # Filter out domains with zero score and sort
    sorted_domains = sorted(
        [(domain, score) for domain, score in domain_scores.items() if score > 0],
        key=lambda x: x[1],
        reverse=True
    )
    
    # Determine top domains - require a minimum score and take top N
    min_score_threshold = 2  # Require at least 2 mentions to be considered significant
    top_n = 3
    top_domains = [
        domain for domain, score in sorted_domains 
        if score >= min_score_threshold
    ][:top_n]
    
    return top_domains if top_domains else ["General Health/Mixed"]

def check_nhanes_cycle_recency(text):
    """
    Checks text for YYYY-YYYY date ranges that DIRECTLY FOLLOW an NHANES mention
    according to a specific pattern.
    Validates ranges based on:
    1. Plausibility (within reasonable year boundaries: MIN_PLAUSIBLE_YEAR to currentYear).
    2. Start year is odd, end year is even.
    """
    MIN_PLAUSIBLE_YEAR = 1950
    current_year = datetime.now().year
    MAX_PLAUSIBLE_YEAR = current_year
    
    # This regex specifically looks for "NHANES_KEYWORD [optional_words] YYYY-YYYY"
    # The NHANES keyword part is MANDATORY for a match
    nhanes_then_date_range_regex = r'(?:NHANES|National Health and Nutrition Examination Survey)\\s*(?:data)?\\s*(?:from)?\\s*(?:the)?\\s*(?:years?)?\\s*((?:19|20)\\d{2})\\s*[-–—]\\s*((?:19|20)\\d{2})'
    
    # Find matches in text
    matches = re.findall(nhanes_then_date_range_regex, text, re.IGNORECASE)
    
    found_valid_range = False
    found_invalid_range = False
    found_implausible_range = False
    valid_range_details = []
    invalid_range_details = []
    implausible_range_details = []
    
    if not matches:
        return {
            'passed': True,  # Pass leniently if no "NHANES... YYYY-YYYY" pattern is found
            'details': "No date ranges found directly following an NHANES mention with the expected pattern."
        }
    
    # Find full context matches to show in details
    full_matches = re.findall(r'(?:NHANES|National Health and Nutrition Examination Survey)\\s*(?:data)?\\s*(?:from)?\\s*(?:the)?\\s*(?:years?)?\\s*(?:19|20)\\d{2}\\s*[-–—]\\s*(?:19|20)\\d{2}', text, re.IGNORECASE)
    
    for i, year_pair in enumerate(matches):
        if len(year_pair) == 2:
            start_year = int(year_pair[0])
            end_year = int(year_pair[1])
            
            match_text = full_matches[i] if i < len(full_matches) else f"NHANES {start_year}-{end_year}"
            
            is_plausible = (
                start_year >= MIN_PLAUSIBLE_YEAR and
                end_year <= MAX_PLAUSIBLE_YEAR and
                end_year >= start_year
            )
            
            if not is_plausible:
                found_implausible_range = True
                implausible_range_details.append(f"{start_year}-{end_year} (in \\"{match_text}\\")")
                continue
            
            if start_year % 2 == 1 and end_year % 2 == 0:
                found_valid_range = True
                valid_range_details.append(f"{start_year}-{end_year}")
            else:
                found_invalid_range = True
                invalid_range_details.append(f"{start_year}-{end_year} (in \\"{match_text}\\")")
    
    # Determine final result based on findings
    details = ""
    passed = True
    
    if found_valid_range:
        passed = True
        details = f"Valid OddStart-EvenEnd date range(s) following an NHANES mention found: {', '.join(list(set(valid_range_details)))}."
        if found_invalid_range:
            details += f" (Also found plausible ranges following NHANES mentions that failed the OddStart-EvenEnd rule: {', '.join(list(set(invalid_range_details)))})"
    elif found_invalid_range:
        passed = False
        details = f"No valid OddStart-EvenEnd ranges confirmed following NHANES mentions. Found plausible ranges with issues: {', '.join(list(set(invalid_range_details)))}."
    elif found_implausible_range:
        passed = True  # Lenient pass if only implausible ones were found matching the pattern
        details = "Found date ranges following NHANES mentions, but they were filtered out as implausible (e.g., out of date bounds)."
    else:
        passed = True  # Pass leniently
        details = "Could not definitively validate year ranges from the 'NHANES...YYYY-YYYY' patterns found."
    
    return {'passed': passed, 'details': details}

def check_title_template(text):
    """Check if the title appears to use a templated structure"""
    # Extract the title
    title_regex = r'^(?:Title\\s*[:\\s]*)?([^\\n]+)'
    title_match = re.search(title_regex, text, re.IGNORECASE)
    
    if not title_match or not title_match.group(1):
        return {
            'passed': True,  # Pass if title can't be found reliably
            'details': "Could not reliably extract a title to check for templating."
        }
    
    title = title_match.group(1).strip()
    
    # Patterns indicative of common templates
    association_pattern = r'\\b(association|relationship|correlation|link|association|impact|effect|influence|predictor)\\b.*?\\b(between|among|of|on|with)\\b'
    population_pattern = r'\\b(among|in|across|within)\\b.*?\\b(U\\.S\\.|US|American|population|adults|children|adolescents|participants|individuals|subjects|men|women|patient)\\b'
    study_design_pattern = r'\\b(cross-sectional|longitudinal|cohort|survey|analysis|study)\\b'
    nhanes_pattern = r'\\b(NHANES|National Health and Nutrition Examination Survey)'
    
    # Score based on presence of these elements
    score = 0
    if re.search(association_pattern, title, re.IGNORECASE):
        score += 1
    if re.search(population_pattern, title, re.IGNORECASE):
        score += 1
    if re.search(study_design_pattern, title, re.IGNORECASE) or re.search(nhanes_pattern, title, re.IGNORECASE):
        score += 1
    
    # Check for generic phrases often found in templates
    common_phrases = bool(re.search(r'\\b(data from the|using data from|analysis of|based on the)\\b', title, re.IGNORECASE))
    
    # Check for keyword stuffing (arbitrary threshold for too many keywords)
    words = [w for w in re.split(r'[\\s,:-]+', title.lower()) if len(w) > 2]
    keyword_stuffing = len(words) > 15
    
    # Define failure conditions
    if score >= 2 and common_phrases:
        return {
            'passed': False,
            'details': f'Title "{title}" appears potentially templated (Score: {score}, Common Phrase: Yes). Contains common association/population/study elements.'
        }
    
    if score >= 3:
        return {
            'passed': False,
            'details': f'Title "{title}" appears strongly templated (Score: {score}). Matches multiple common patterns.'
        }
    
    if keyword_stuffing:
        return {
            'passed': False,
            'details': f'Title "{title}" might be overly long or keyword-stuffed.'
        }
    
    return {
        'passed': True,
        'details': f'Title does not appear excessively templated (Score: {score}, Common Phrase: {"Yes" if common_phrases else "No"}).'
    }

def check_author_red_flags(text):
    """Check for red flags in author information including non-institutional emails, mismatched affiliations, etc."""
    # Get topics using the extracted function
    topics = extract_manuscript_topics(text)
    
    # Find author/affiliation section
    author_section_regex = r'(?:\\bAbstract\\b[\\s\\S]*?)(?:\\n\\s*(?:Authors?|Affiliations?)\\b\\s*[:\\n]?)([\\s\\S]*?)(?=\\n\\s*\\b(Introduction|Background|Methods|Results|Discussion|Conclusion|References|Acknowledgments)\\b|\\n{3,})'
    author_section_match = re.search(author_section_regex, text, re.IGNORECASE)
    author_section = author_section_match.group(1).strip() if author_section_match else ""
    
    # Fallback: If no clear section, look broadly for emails and affiliations near the start
    if not author_section:
        first_part_of_text = text[:3000]
        email_regex_global = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b'
        affiliation_regex_global = r'\\b(?:Department|Dept|Division|School|Faculty|Center|Institute|Hospital|University|College)\\b'
        
        if (re.search(email_regex_global, first_part_of_text, re.IGNORECASE) or 
            re.search(affiliation_regex_global, first_part_of_text, re.IGNORECASE)):
            # Consider the first ~1000 characters as potential author info section
            author_section = first_part_of_text[:1000]
        else:
            return {
                'passed': True,  # Cannot perform check if no author info found
                'details': "Could not reliably extract author/affiliation information."
            }
    
    # --- Flag 1: Non-Institutional Emails ---
    email_regex = r'\\b[A-Za-z0-9._%+-]+@([A-Za-z0-9.-]+\\.[A-Za-z]{2,})\\b'
    emails = re.findall(email_regex, author_section)
    non_institutional_domains = [
        'gmail\\.com', 'yahoo\\.com', 'hotmail\\.com', 'outlook\\.com', 
        'aol\\.com', 'icloud\\.com', 'protonmail\\.com', 'qq\\.com', 
        '163\\.com', 'mail\\.com', 'yandex\\.com'
    ]
    non_inst_pattern = '|'.join(non_institutional_domains)
    non_institutional_emails = [email for email in emails if re.search(non_inst_pattern, email, re.IGNORECASE)]
    
    # Flag if > 50% are non-institutional AND there's at least one such email
    has_non_institutional_emails = False
    email_flag_details = ''
    if emails:
        has_non_institutional_emails = (len(non_institutional_emails) / len(emails) > 0.5)
        if has_non_institutional_emails:
            email_flag_details = f'Majority ({len(non_institutional_emails)}/{len(emails)}) non-institutional emails; '
    
    # --- Flag 2: Mismatched Departments/Affiliations ---
    affiliation_regex = r'\\b(?:Department|Dept|Division|School|Faculty|Center|Institute|Hospital|University|College|Laboratory|Program|Unit|Clinic)\\s+(?:of\\s+)?([A-Za-z\\s,&\\'-]+)'
    affiliation_matches = re.findall(affiliation_regex, author_section, re.IGNORECASE)
    affiliations = [re.sub(r'[\\d,.;]+$', '', match).strip().lower() for match in affiliation_matches]
    
    # Relevance mapping for affiliations
    relevance_mappings = {
        "Cardiovascular": ["cardiology", "cardiovascular", "vascular", "heart", "preventive medicine", "internal medicine"],
        "Nutrition/Diet": ["nutrition", "dietetics", "food science", "public health", "preventive medicine", "metabolism"],
        "Metabolic/Endocrine": ["endocrinology", "metabolic", "diabetes", "obesity", "medicine", "internal medicine"],
        "Epidemiology/Public Health": ["epidemiology", "public health", "biostatistics", "community health", "preventive medicine", "statistics", "population health"],
        "Mental Health/Neurology": ["psychiatry", "psychology", "neurology", "behavioral", "neuroscience", "mental health"],
        "General Health/Mixed": ["medicine", "health science", "public health", "biology", "biostatistics", "statistics", "internal medicine", "family medicine", "nursing", "pharmacy"]
    }
    
    relevant_affiliations_count = 0
    unique_affiliations = list(set([affil for affil in affiliations if len(affil) > 2]))
    
    for affil in unique_affiliations:
        is_relevant = False
        # Check against identified topics
        for topic in topics:
            relevant_terms = relevance_mappings.get(topic, relevance_mappings["General Health/Mixed"])
            if any(term in affil for term in relevant_terms):
                is_relevant = True
                break
        
        # Check against general health terms if not already relevant
        if not is_relevant:
            general_terms = relevance_mappings["General Health/Mixed"]
            if any(term in affil for term in general_terms):
                is_relevant = True
        
        if is_relevant:
            relevant_affiliations_count += 1
    
    # Flag if < 50% affiliations seem relevant AND there are affiliations listed
    has_mismatched_affiliations = False
    mismatch_flag_details = ''
    if unique_affiliations:
        has_mismatched_affiliations = (relevant_affiliations_count / len(unique_affiliations)) < 0.5
        if has_mismatched_affiliations:
            mismatch_flag_details = f'Affiliations ({relevant_affiliations_count}/{len(unique_affiliations)} relevant) may not align well with topics ({", ".join(topics)}); '
    
    # --- Flag 3: Claims of Data Collection ---
    collection_context_regex = r'\\b(?:we|authors?)\\s+(?:collected|gathered|obtained|acquired|assembled|recruited)\\s+(?:(?:the|these|our)\\s+)?(?:participants|subjects|(?:NHANES\\s+)?data)\\b'
    claims_data_collection = bool(re.search(collection_context_regex, text, re.IGNORECASE))
    collection_flag_details = 'Potentially claims to have collected the NHANES data/participants; ' if claims_data_collection else ''
    
    # --- Combine Flags ---
    red_flags_found = [flag for flag in [has_non_institutional_emails, has_mismatched_affiliations, claims_data_collection] if flag]
    red_flag_count = len(red_flags_found)
    
    if red_flag_count >= 1:  # Fail on 1 or more strong flags
        details = f'Found {red_flag_count} potential author/affiliation red flag(s): {email_flag_details}{mismatch_flag_details}{collection_flag_details}'
        return {
            'passed': False,
            'details': details.strip()
        }
    
    return {
        'passed': True,
        'details': f'Author information appears plausible ({red_flag_count} red flags detected). Topics: {", ".join(topics)}.'
    }

# --- File Processing Functions ---

async def read_text_file(file):
    """Read a text file"""
    try:
        content = await window.NHANESBridge.fetchTextFromFile(file)
        return content
    except Exception as e:
        raise Exception(f"Error reading text file: {str(e)}")

async def read_docx_file(file):
    """Read a DOCX file using mammoth.js"""
    try:
        array_buffer = await window.NHANESBridge.fetchArrayBufferFromFile(file)
        result = await mammoth.extractRawText({'arrayBuffer': array_buffer})
        return result.value
    except Exception as e:
        raise Exception(f"Error processing DOCX: {str(e)}")

async def read_pdf_file(file, progress_callback=None):
    """Read a PDF file using PDF.js"""
    try:
        # Read file as array buffer
        array_buffer = await window.NHANESBridge.fetchArrayBufferFromFile(file)
        
        # Set PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js'
        
        # Load PDF document
        loading_task = pdfjsLib.getDocument({'data': array_buffer})
        pdf = await loading_task.promise
        
        # Initialize progress tracking
        total_pages = pdf.numPages
        pages_processed = 0
        
        if progress_callback:
            progress_callback(pages_processed, total_pages)
        
        # Extract text from all pages
        page_texts = []
        
        for i in range(1, total_pages + 1):
            # Get page
            page = await pdf.getPage(i)
            
            # Extract text content
            text_content = await page.getTextContent()
            
            # Join text items
            page_text = ' '.join([item.str for item in text_content.items])
            page_texts.append(page_text)
            
            # Update progress
            pages_processed += 1
            if progress_callback:
                progress_callback(pages_processed, total_pages)
        
        # Join all pages with double newlines
        full_text = '\\n\\n'.join(page_texts)
        return full_text
    except Exception as e:
        raise Exception(f"Error processing PDF: {str(e)}")

# --- UI Functions ---

def display_results(results):
    """Display check results in the UI"""
    # Get references to HTML elements
    results_el = document.getElementById('results')
    results_content = document.getElementById('resultsContent')
    
    # Ensure elements exist
    if not results_el or not results_content:
        console.error("UI Error: Results container elements not found in the DOM.")
        return
    
    # Make results section visible
    results_el.classList.remove('hidden')
    
    # Clear any previous results
    results_content.innerHTML = ''
    
    # --- Overall Result Banner ---
    overall_result_div = document.createElement('div')
    overall_class = 'check-item'  # Base class
    result_text = f"Overall Result: {results['finalResult']}"
    
    # Apply specific class based on the final result
    if results['finalResult'] == 'Pass':
        overall_class += ' pass'
    elif results['finalResult'] == 'Fail':
        overall_class += ' fail'
        # Add step failure detail if available
        if results.get('failStep', 0) > 0:
            result_text += f" (Failed at Step {results['failStep']})"
    elif results['finalResult'] == 'Not NHANES':
        overall_class += ' not-nhanes'
    elif results['finalResult'] == 'Error':
        overall_class += ' fail'  # Style errors as failures
        result_text = 'Processing Error'
    else:
        overall_class += ' not-nhanes'
        result_text = f"Result: {results['finalResult'] or 'Unknown'}"
    
    overall_result_div.className = overall_class
    overall_result_div.innerHTML = f'<div class="summary">{result_text}</div>'
    results_content.appendChild(overall_result_div)
    
    # --- Summary Details Section ---
    if results.get('details') and isinstance(results['details'], list) and results['details']:
        summary_details_div = document.createElement('div')
        summary_details_div.className = 'summary-details'
        summary_details_div.innerHTML = '<h3>Processing Details:</h3>'
        
        summary_list = document.createElement('ul')
        
        for detail in results['details']:
            item = document.createElement('li')
            item.textContent = detail
            
            # Apply inline styles based on prefixes
            if detail.startswith('✗'):
                item.style.color = '#dc3545'  # Fail color
                item.style.fontWeight = 'bold'
            elif detail.startswith('✓'):
                item.style.color = '#28a745'  # Pass color
            elif detail.startswith('⚠️'):
                item.style.color = '#ffc107'  # Warning color
                item.style.fontWeight = 'bold'
            
            summary_list.appendChild(item)
        
        summary_details_div.appendChild(summary_list)
        results_content.appendChild(summary_details_div)
    
    # --- Individual Check Results Section (Collapsible) ---
    if results.get('checkResults') and isinstance(results['checkResults'], list) and results['checkResults']:
        checks_section = document.createElement('details')
        checks_section.className = 'individual-checks'
        
        summary_toggle = document.createElement('summary')
        summary_toggle.innerHTML = '<h3>Individual Check Details ▼</h3>'
        checks_section.appendChild(summary_toggle)
        
        # Add details for each check result
        for check in results['checkResults']:
            check_item = document.createElement('div')
            status_text = ''
            item_class = 'check-item'  # Base class for styling
            
            if check.get('skipped', False):
                item_class += ' skipped'
                status_text = '<span style="color:#6c757d; font-weight:bold;">⚪ Skipped</span>'
            elif check.get('passed', False):
                item_class += ' pass'
                status_text = '<span style="color:#28a745; font-weight:bold;">✓ Pass</span>'
            else:
                item_class += ' fail'
                status_text = '<span style="color:#dc3545; font-weight:bold;">✗ Fail</span>'
            
            check_item.className = item_class
            
            # Populate the check item's content
            check_item.innerHTML = f"""
                <h4>{check.get('checkName', 'Unknown Check')}: {status_text}</h4>
                <p>{check.get('details', 'No details provided.')}</p>
            """
            
            checks_section.appendChild(check_item)
        
        results_content.appendChild(checks_section)

# Main orchestration function
def check_nhanes_manuscript(text, title='Untitled Manuscript'):
    """Main orchestration function"""
    console.log(f'Checking manuscript: {title}')
    
    # Check 1: Does it mention NHANES?
    has_nhanes = check_for_nhanes(text)
    
    if not has_nhanes:
        return {
            'isNHANES': False,
            'finalResult': "Not NHANES",
            'details': ["The manuscript does not appear to use NHANES data."],
            'checkResults': []
        }
    
    results = {
        'isNHANES': True,
        'checkResults': [],
        'details': ["✓ STEP 1: Manuscript mentions NHANES."],
        'finalResult': "",
        'failStep': 0  # Track which step caused failure
    }
    
    # Define checks in order
    checks = [
        {"name": "2a. NHANES Citation", "func": check_nhanes_citation, "step": 2, "critical": True},
        {"name": "2b. Survey Design Acknowledgment", "func": check_survey_design_acknowledgment, "step": 2, "critical": True},
        {"name": "2c. Weighting Methodology", "func": check_weighting_methodology, "step": 2, "critical": True},
        {"name": "3. NHANES Date Range", "func": check_nhanes_date_range, "step": 3, "critical": False},
        {"name": "4. NHANES Cycle Recency", "func": check_nhanes_cycle_recency, "step": 4, "critical": False},
        {"name": "5. Title Template Check", "func": check_title_template, "step": 5, "critical": False},
        {"name": "6. Author Red Flags", "func": check_author_red_flags, "step": 6, "critical": False}
    ]
    
    current_step = 1
    methodology_passed = True  # Specifically track step 2 passes
    
    for check in checks:
        # Update step summary if moving to a new step number
        if check["step"] > current_step:
            # Check if Step 2 (Methodology) failed overall before moving on
            if current_step == 2 and not methodology_passed:
                results['finalResult'] = "Fail"
                results['failStep'] = 2
                results['details'].append("✗ STEP 2: Failed one or more critical methodology checks.")
                break  # Stop processing critical methodology failure
            
            # Log success of the previous step block (if not already failed)
            if results['finalResult'] != "Fail":
                results['details'].append(f"✓ STEP {current_step}: Check(s) passed.")
            
            current_step = check["step"]  # Move to the new step number
        
        # Execute the check function
        check_result = check["func"](text)
        results['checkResults'].append({
            'checkName': check["name"],
            'passed': check_result.get('passed', False),
            'details': check_result.get('details', ''),
            'skipped': check_result.get('skipped', False)
        })
        
        # Handle failed check (only if not skipped)
        if not check_result.get('passed', False) and not check_result.get('skipped', False):
            if check["step"] == 2:
                methodology_passed = False
            
            if check["critical"]:
                results['finalResult'] = "Fail"
                results['failStep'] = check["step"]
                if not any(d.startswith('✗ STEP') for d in results['details']):
                    results['details'].append(f"✗ STEP {check['step']}: Failed critical check \\"{check['name']}\\".")
                
                if check["step"] > 2:
                    break
            else:
                results['details'].append(f"⚠️ STEP {check['step']}: Non-critical issue found in check \\"{check['name']}\\".")
    
    # Set final results
    if current_step == 2 and not methodology_passed and results['finalResult'] != "Fail":
        results['finalResult'] = "Fail"
        results['failStep'] = 2
        results['details'].append("✗ STEP 2: Failed one or more critical methodology checks.")
    
    # If loop completed and no critical failure occurred, log success for the last step
    if results['finalResult'] != "Fail":
        results['details'].append(f"✓ STEP {current_step}: Check(s) passed.")
        results['finalResult'] = "Pass"
        results['details'].append("✓ ALL CRITICAL CHECKS PASSED.")
    else:
        if results['failStep'] == 0 and results['isNHANES']:
            results['failStep'] = current_step
        
        results['details'].append(f"✗ Manuscript check failed at Step {results['failStep']}.")
    
    return results

# --- Event Handlers ---

async def handle_file_upload(event):
    """Handle file upload event"""
    file = event.target.files[0]
    if not file:
        return
    
    # Clear results
    document.getElementById('results').classList.add('hidden')
    document.getElementById('resultsContent').innerHTML = ''
    
    # Show loading
    window.NHANESBridge.showUILoading(f"Loading file: {file.name}...")
    
    try:
        # Process file based on extension
        file_extension = file.name.split('.')[-1].lower()
        
        if file_extension == 'txt':
            content = await read_text_file(file)
        elif file_extension == 'docx':
            content = await read_docx_file(file)
        elif file_extension == 'pdf':
            # Create progress callback
            def update_progress(current, total):
                window.NHANESBridge.showUILoading(f"Loading PDF: {file.name} ({current}/{total} pages)...")
            
            progress_proxy = create_proxy(update_progress)
            content = await read_pdf_file(file, progress_proxy)
        else:
            error_msg = f"Unsupported file type: .{file_extension}. Please upload a .txt, .docx, or .pdf file."
            document.getElementById('manuscriptText').value = error_msg
            alert(error_msg)
            window.NHANESBridge.hideUILoading(False)
            return
            
        # Update textarea with content
        document.getElementById('manuscriptText').value = content
        window.NHANESBridge.hideUILoading(True)
        
    except Exception as e:
        error_msg = f"Error processing file: {str(e)}"
        document.getElementById('manuscriptText').value = error_msg
        alert(error_msg)
        window.NHANESBridge.hideUILoading(False)

def handle_check_button(event):
    """Handle check button click"""
    manuscript_text = document.getElementById('manuscriptText').value
    
    if not manuscript_text.strip() or manuscript_text.startswith("Loading") or manuscript_text.startswith("Error") or manuscript_text.startswith("Unsupported"):
        alert('Please wait for loading to complete or upload a valid file content.')
        return
        
    document.getElementById('results').classList.add('hidden')
    window.NHANESBridge.showUILoading("Running NHANES checks...")
    
    try:
        # Run the checks
        results = check_nhanes_manuscript(manuscript_text, "Manuscript")
        display_results(results)
    except Exception as e:
        console.error("Error during manuscript check:", e)
        # Display error results
        error_results = {
            'finalResult': "Error",
            'details': [f"An unexpected error occurred during analysis: {str(e)}"],
            'checkResults': []
        }
        display_results(error_results)
    finally:
        window.NHANESBridge.hideUILoading(True)
        # Scroll to results if needed
        if document.getElementById('resultsContent').innerHTML.trim() != '':
            document.getElementById('results').scrollIntoView({'behavior': 'smooth', 'block': 'start'})

def handle_clear_button(event):
    """Handle clear button click"""
    document.getElementById('manuscriptText').value = ''
    document.getElementById('manuscriptFile').value = ''
    document.getElementById('results').classList.add('hidden')
    document.getElementById('resultsContent').innerHTML = ''
    document.getElementById('checkButton').disabled = True

# --- Initialization ---

def initialize():
    """Initialize the application"""
    console.log("Initializing NHANES Checker (Python version)")
    
    # Hide the loading message and show the app
    document.getElementById('pyodideLoading').classList.add('hidden')
    document.getElementById('appContent').classList.remove('hidden')
    
    # Set up event listeners
    check_button = document.getElementById('checkButton')
    if check_button:
        check_button.addEventListener('click', create_proxy(handle_check_button))
    
    file_input = document.getElementById('manuscriptFile')
    if file_input:
        file_input.addEventListener('change', create_proxy(handle_file_upload))
    
    clear_button = document.getElementById('clearButton')
    if clear_button:
        clear_button.addEventListener('click', create_proxy(handle_clear_button))
    
    # Set up textarea input change detection
    textarea = document.getElementById('manuscriptText')
    if textarea:
        def enable_check_if_text(event):
            check_button.disabled = not bool(textarea.value.strip())
        textarea.addEventListener('input', create_proxy(enable_check_if_text))
    
    # Initial UI state
    window.NHANESBridge.hideUILoading(False)
    console.log("NHANES Checker initialized and ready")

# Entry point - initialize everything
initialize()
        `;
        
        // Run the Python code
        await pyodide.runPythonAsync(pythonCode);
        
        console.log("Python implementation loaded successfully!");
      } catch (error) {
        console.error("Error initializing Pyodide:", error);
        document.getElementById('pyodideLoading').innerHTML = 
          '<div style="color: #dc3545; font-weight: bold;">Error loading Python environment: ' + 
          error.message + '</div><div>Please refresh the page to try again.</div>';
      }
    }
    
    // Start the application
    main();
  </script>
</body>
</html>